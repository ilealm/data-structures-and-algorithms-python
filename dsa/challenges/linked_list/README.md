# Linked List
This challenge was a excercise over Linklist.

## Challenge
### Challenge 05: insertion, displaying_nodes and searching.

challenges/linked_list/linked_list.py
GitHub Pull# 4

[Pull on GitHub](https://github.com/ilealm/data-structures-and-algorithms-python/pull/4)


## Approach & Efficiency
For the insertion method, this code have Big O(1) because is inserting at the begining of the list, not moving or traversing existing nodes.

For displaying all the nodes, have Big O(n), because can be conpromises depenging the longitude of the list.

For searching a value, the Big O(n), because the searched element can be the last on the list, ot not exist. As an inprovement, once the element if
founded on the list, it stop traversing.

## Solution
Solution for lab 6, Linked List v2

___________
# Linked List , part 2: append, insert_before and insert_after
In this0 challenge we add methods over Linklist.

## Challenge
### Challenge 06

challenges/linked_list/linked_list.py
GitHub Pull# 5

[Pull on GitHub](https://github.com/ilealm/data-structures-and-algorithms-python/pull/5)


## Approach & Efficiency
For append method, this code have Big O(n) becausein worse case scenario, we have to traver all existing nodes.

For insert_before method, this code have Big O(n) becausein worse case scenario, we have to traver all existing nodes.

For insert_after method, this code have Big O(n) becausein worse case scenario, we have to traver all existing nodes.


## Solution
Solution for lab 6, Linked List v2

_Sorry for the bad gritting...._

![My solution](/assets/linked_list.jpg)


___________
# Linked List , part 3
In this challenge we add the get value of k position starting on the end, over Linklist.

## Challenge
### Challenge 07

challenges/linked_list/linked_list.py
GitHub Pull# 6

[Pull on GitHub](https://github.com/ilealm/data-structures-and-algorithms-python/pull/6)


## Approach & Efficiency

In this function we have Big O(n2) because we have to traverse one all the nodes to know how many nodes are (function how_many_nodes), and then,
in worse case scenario, we have to traverse again all existing nodes if the k_value = 1.


## Solution
Solution for lab 6, Linked List v3



![My solution](/assets/linked_list_kValue.jpg)

